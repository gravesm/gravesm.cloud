##########################################
Declared State Ansible for Cloud Resources
##########################################

This is an experimental demo intended to show how we could use Ansible as it currently exists to manage cloud-based resources in a more declarative way. All the logic is handled at the collection level.

If you have an AWS account, you can run the demo with::

  $ ansible-playbook playbook.yml

The ``resources.yml`` file contains the set of resources that will be created. In this example, it's just four S3 buckets. We're currently limited by what the AWS Cloud Control API supports, but this should be enough to show what's possible. To clean up just run::

  $ ansible-playbook playbook.yml --extra-vars "state=absent"

This will delete the four buckets it created.

Goals
=====

Most cloud providers offer some sort of RESTful API for managing resources. If we replace the imperative task-based approach that Ansible is known for with a declared state approach that better matches REST, we can achieve a number of interesting features. With a well defined REST API, we can abstract most of the interaction down to two variables: the method and the payload.

The goals for this demo are to show:

* simplified resource management by authoring only desired resource state
* performance improvements through concurrent resource management
* easy provisioning and deprovisioning of the same resource definitions
* seamlessly switch between declared state management and imperative task-based management

Implementation
==============

There are two parts to this demo. The first collection ``gravesm.cloud`` contains the logic for creating the dependency graph of resources. There is also an action plugin that provides some syntactic sugar for defining resources. While not strictly necessary, this action plugin lets us easily define all our resources in a vars file. The ``gravesm.cloud`` collection delegates the actual CRUD operations to the ``gravesm.aws`` collection.

State (present/absent) has been fully decoupled from the resource declaration. Provisioning and deprovisioning a set of resources can be as simple as::

  $ ansible-playbook playbook.yml --extra-vars "state=present"
  $ ansible-playbook playbook.yml --extra-vars "state=absent"

The resource file
-----------------

The resource file (``resources.yml`` in this example) is just an Ansible vars file. The resources could be provided in any way that you typically provide variables. Top level keys in the file map to task names in the playbook. Each entry in the vars file is a list of resources. The ``name`` of each resource should be unique within a collection of resources as the local resource name is used to set up a dependency between resources. In this demo, a dependency on another resource is established by using a ``resource:<resource_name>`` token. Because the resources are created in the correct order, the actual state is available to later resources. This means that properties from the included resource can be accessed and will use the actual state.

For example::

  cloud:
    - name: resource_a
      properties:
        foo: resource:resource_b.autogenerated_property
    - name: resource_b

In this case, ``resource_b`` will be created first even though it is defined last. The actual state of ``resource_b`` will be available to ``resource_a`` when it is created, so it can access a property that does not exist in the desired state.

gravesm.cloud
-------------

This collection acts more like a library. Another collection calls the ``run()`` function and passes it a list of resources, an API client and the desired state of the resources, i.e. `present` or `absent`. The primary job of this function is to generate a graph of dependencies between resources so that they can be created/deleted in the correct order (the order in which resources are declared does not matter). The direction of the graph will depend on the state. In other words, for the `absent` state we need to reverse the order that we used for the `present` state. The actual work of doing anything with those resources is handled by another collection.

The graph is processed in batches. Each pass over the graph will produce a batch of resources with no unmet dependencies. This allows us to manage the state of all the resources in a particular batch concurrently, since there are no dependencies between them. As resources are created/deleted the actual state is stored. When it's finished this stored state is returned.

gravesm.aws
-----------

This collection is responsible for doing all the state work on the resources. All the AWS client specific logic lives here. The design intent is that each cloud provider would have its own collection.

Further Remarks
===============

In addition to the basic functionality described here, the demo playbook shows a few other interesting features:

* We can see how it's possible to integrate this new declared state approach seamlessly into a more traditional imperative approach, and switch between the two.
* Multiple clouds can be supported in a single playbook. One could even support multiple accounts of the same cloud provider since resources are namespaced to a task.
* The actual state of the resources is returned from the task. It should be possible to create pluggable state storage through callback plugins. This might open up new opportunities.
* Though it's not evident from the output, during the creation of resources for the ``cloud_1`` collection, the ``bucket_02`` and ``bucket_03`` buckets are created concurrently, as they have no resource dependencies.
* The playbook itself is very simple and predictable. In fact, the resources file has everything that's needed to run a task. The playbook could be autogenerated on the fly if desired.

Limitations
===========

This experiment is mostly just to demonstrate what could be possible. There are a number of limitations here, but I'll point out a few of the more noteworthy:

* In order to keep the actual state of the resources easily accessible, I had to sacrifice the ability to see which individual resources changed. This is less about how to determine what has changed and more about how to represent that change in a way that keeps the state usable later.
* This design works because we can aggresively abstract much of the logic down to a few simple operations. When applied across numerous different APIs I would expect things to break down some.
